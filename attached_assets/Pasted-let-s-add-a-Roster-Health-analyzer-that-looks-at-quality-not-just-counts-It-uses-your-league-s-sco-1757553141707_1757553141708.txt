let’s add a Roster Health analyzer that looks at quality, not just counts. It uses your league’s scoring + your projections to measure surplus/shortage by position, tiers your players (Elite/Starter/Flex-worthy/Depth/Replaceable), and outputs trade/waiver recommendations.

Below is a clean drop-in plan for Replit AI.

1) Types
// src/lib/types.ts
export type PosStrength = {
  pos: string;
  demand: number;          // how many of this pos you actually start (from optimal lineup)
  startersProj: number;    // sum of projections for starters at this pos
  depthProjWeighted: number; // weighted bench quality (diminishing returns)
  replacementBaseline: number; // baseline per-starter from FA pool
  surplus: number;         // startersProj - demand * replacementBaseline
  shortage: number;        // max(0, demand*replacementBaseline - startersProj)
  tiers: { label: string; name: string; proj: number }[]; // elite/starter/flex/depth/repl
};

export type RosterHealth = {
  byPos: PosStrength[];
  strongest: string[];
  weakest: string[];
  tradeIdeas: { give: string; forNeed: string; rationale: string }[];
  addDropIdeas: { pos: string; addName: string; gain: number; dropName?: string }[];
};

2) Roster Health engine
// src/lib/rosterHealth.ts
import type { LeagueSummary } from "./types";
import type { WaiverSuggestion } from "./types"; // if you defined earlier
import { normalizePos } from "./projections";

type FAIndex = Record<string, { name:string; proj:number }[]>; // pos -> sorted FA list

const DECAY = [0.5, 0.3, 0.2]; // bench depth weights (top3 bench at a pos)

function group<T>(arr:T[], key:(x:T)=>string) {
  return arr.reduce<Record<string,T[]>>((m, x) => {
    const k = key(x); (m[k] ||= []).push(x); return m;
  }, {});
}

export function computeRosterHealth(opts: {
  lg: LeagueSummary;
  faByPos: FAIndex | null; // null if you didn’t build FA pool
}): import("./types").RosterHealth {

  const { lg, faByPos } = opts;

  // 1) How many of each position are actually started? (quality-aware demand)
  const startedPlayers = lg.optimalSlots
    .map(s => s.player)
    .filter(Boolean) as { player_id:string; name:string; pos:string; proj:number }[];

  const demandByPos: Record<string, number> = {};
  startedPlayers.forEach(p => {
    const pos = normalizePos(p.pos);
    demandByPos[pos] = (demandByPos[pos] ?? 0) + 1;
  });

  // 2) Starter quality per position
  const startersByPos = group(startedPlayers, p => normalizePos(p.pos));
  const startersProjByPos: Record<string, number> = {};
  Object.keys(startersByPos).forEach(pos => {
    startersProjByPos[pos] = startersByPos[pos].reduce((a, b) => a + (b.proj ?? 0), 0);
  });

  // 3) Bench quality with diminishing returns
  // Bench = your rostered players – starters (IDs)
  const startedIds = new Set(startedPlayers.map(p => p.player_id));
  const benchPlayers = (lg.benchDetail || []) as { player_id:string; name:string; pos:string; proj:number }[]; // optional: fill in App.tsx
  const benchByPos = group(benchPlayers.filter(b => !startedIds.has(b.player_id)), b => normalizePos(b.pos));
  const depthWeightedByPos: Record<string, number> = {};
  Object.keys(benchByPos).forEach(pos => {
    const arr = benchByPos[pos].slice().sort((a,b)=> (b.proj??0)-(a.proj??0));
    const weighted = arr.slice(0, DECAY.length).reduce((sum, p, i) => sum + (p.proj ?? 0)*DECAY[i], 0);
    depthWeightedByPos[pos] = weighted;
  });

  // 4) Replacement baseline from FA pool (average of top K per pos)
  const K = 5;
  const replacementPerPos: Record<string, number> = {};
  Object.keys(demandByPos).forEach(pos => {
    const pool = faByPos?.[pos] ?? [];
    const avg = pool.slice(0, K).reduce((a,b)=>a+(b.proj??0),0) / Math.max(1, Math.min(K, pool.length || 1));
    replacementPerPos[pos] = avg || 0;
  });

  // 5) Build strength objects
  const allPositions = Array.from(new Set(Object.keys(demandByPos)
    .concat(Object.keys(startersProjByPos))
    .concat(Object.keys(depthWeightedByPos))));

  const byPos = allPositions.map(pos => {
    const demand = demandByPos[pos] ?? 0;
    const startersProj = startersProjByPos[pos] ?? 0;
    const depthProjWeighted = depthWeightedByPos[pos] ?? 0;
    const replacementBaseline = replacementPerPos[pos] ?? 0;
    const needPoints = demand * replacementBaseline;
    const surplus = startersProj - needPoints;
    const shortage = Math.max(0, needPoints - startersProj);

    // Tier players at this pos
    const posPlayers = (startersByPos[pos] ?? []).concat(benchByPos[pos] ?? []);
    const tiers = tierPlayers(posPlayers, replacementBaseline);

    return { pos, demand, startersProj, depthProjWeighted, replacementBaseline, surplus, shortage, tiers };
  });

  // 6) Identify strongest/weakest positions
  const strongest = byPos.slice().sort((a,b)=> (b.surplus + b.depthProjWeighted) - (a.surplus + a.depthProjWeighted))
                  .slice(0,2).map(x => x.pos);
  const weakest  = byPos.slice().sort((a,b)=> (b.shortage) - (a.shortage))
                  .slice(0,2).map(x => x.pos);

  // 7) Trade / add-drop ideas
  const tradeIdeas = strongest.flatMap(give => weakest.map(w => ({
    give, forNeed: w,
    rationale: `Surplus at ${give} (+${fmt(byPos.find(p=>p.pos===give)?.surplus)} pts over replacement) vs shortage at ${w} (${fmt(byPos.find(p=>p.pos===w)?.shortage)} pts).`
  }))).slice(0,3);

  const addDropIdeas: { pos:string; addName:string; gain:number; dropName?:string }[] = [];
  Object.keys(benchByPos).forEach(pos => {
    const faTop = faByPos?.[pos]?.[0];
    if (!faTop) return;
    const worstBench = benchByPos[pos].slice().sort((a,b)=> (a.proj??0)-(b.proj??0))[0];
    if (!worstBench) return;
    const gain = (faTop.proj ?? 0) - (worstBench.proj ?? 0);
    if (gain > 0.5) addDropIdeas.push({ pos, addName: faTop.name, gain, dropName: worstBench.name });
  });

  return { byPos, strongest, weakest, tradeIdeas, addDropIdeas };
}

// Simple tiering relative to replacement baseline
function tierPlayers(players: {name:string; proj:number}[], repl:number) {
  return players.slice().sort((a,b)=> (b.proj??0)-(a.proj??0)).map(p => {
    const diff = (p.proj ?? 0) - repl;
    const label =
      diff >= 6   ? "Elite" :
      diff >= 3   ? "Starter" :
      diff >= 1.0 ? "Flex-worthy" :
      diff >= 0   ? "Depth" : "Replaceable";
    return { label, name: p.name, proj: p.proj ?? 0 };
  });
}

const fmt = (x?:number) => (x ?? 0).toFixed(1);


Why this isn’t “just counts”:

Demand uses your actual starters from the optimized lineup.

Surplus/shortage compares your starters to a replacement baseline from the FA pool.

Depth uses diminishing weights so 3 great bench WRs score higher than 7 mediocre ones.

Tiers classify by value over replacement, not quantity.

3) Provide bench detail (one line in runCheck())

When you build benchObjs, keep a compact form for the health module:

const benchDetail = benchObjs.map(b => ({
  player_id: b.player_id, name: b.name, pos: b.pos, proj: b.proj ?? 0
}));


Include it in your out.push({...}):

benchCapacity,
benchCount,
benchEmpty,
benchDetail, // <-- add this

4) Call the analyzer in runCheck() (per league)

After you already computed optimalSlots, waiverSuggestions, and you have the FA pool (scored) or at least raw FA pool:

import { computeRosterHealth } from "./lib/rosterHealth";

// Build a compact FA index: pos -> [{name, proj}] using your scoredFAs
const faIndex: Record<string, { name:string; proj:number }[]> = {};
if (considerWaivers && scoredFAs) {
  for (const pos of Object.keys(scoredFAs)) {
    faIndex[pos] = scoredFAs[pos].map(x => ({ name: x.name, proj: x.proj ?? 0 }));
}

const rosterHealth = computeRosterHealth({
  lg: {
    ...leagueSummaryObjectYouPush, // or pass the fields the function reads (optimalSlots, benchDetail)
  } as any,
  faByPos: faIndex || null,
});


Store rosterHealth on the league object you push:

out.push({
  ...existing,
  rosterHealth,
});

5) Show it in the UI (inside LeagueCard)

Add a compact section (under totals):

{lg.rosterHealth && (
  <div className="mt-4">
    <div className="font-semibold">Roster Health</div>
    <div className="text-xs text-gray-600 mb-2">
      Surplus/shortage are vs. replacement-level free agents (league scoring).
    </div>

    <table className="w-full text-sm border-separate border-spacing-y-1">
      <thead className="text-xs text-gray-500">
        <tr>
          <th className="text-left">Pos</th>
          <th className="text-right">Demand</th>
          <th className="text-right">Starters</th>
          <th className="text-right">Depth (wgt)</th>
          <th className="text-right">Repl/Start</th>
          <th className="text-right">Surplus</th>
        </tr>
      </thead>
      <tbody>
        {lg.rosterHealth.byPos.map(p => (
          <tr key={p.pos}>
            <td className="font-mono">{p.pos}</td>
            <td className="text-right">{p.demand}</td>
            <td className="text-right">{p.startersProj.toFixed(1)}</td>
            <td className="text-right">{p.depthProjWeighted.toFixed(1)}</td>
            <td className="text-right">{p.replacementBaseline.toFixed(1)}</td>
            <td className={`text-right ${p.surplus >= 0 ? "text-emerald-600" : "text-rose-600"}`}>
              {p.surplus.toFixed(1)}
            </td>
          </tr>
        ))}
      </tbody>
    </table>

    <div className="mt-2 text-sm">
      <b>Strongest:</b> {lg.rosterHealth.strongest.join(", ")} • <b>Weakest:</b> {lg.rosterHealth.weakest.join(", ")}
    </div>

    {lg.rosterHealth.tradeIdeas.length > 0 && (
      <div className="mt-2 text-sm">
        <b>Trade Ideas:</b>
        <ul className="list-disc ml-6">
          {lg.rosterHealth.tradeIdeas.map((t, i) => (
            <li key={i}>
              Package from <b>{t.give}</b> to address <b>{t.forNeed}</b> — {t.rationale}
            </li>
          ))}
        </ul>
      </div>
    )}

    {lg.rosterHealth.addDropIdeas.length > 0 && (
      <div className="mt-2 text-sm">
        <b>Waiver Ideas:</b>
        <ul className="list-disc ml-6">
          {lg.rosterHealth.addDropIdeas.map((w, i) => (
            <li key={i}>
              {w.pos}: Add <b>{w.addName}</b> (+{w.gain.toFixed(2)} pts)
              {w.dropName && <> ; drop <b>{w.dropName}</b></>}
            </li>
          ))}
        </ul>
      </div>
    )}
  </div>
)}
