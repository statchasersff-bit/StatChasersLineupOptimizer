âœ… Product goals

Single screen per Sleeper user: /{sleeperUsername}/matchups

No Best Ball leaguesâ€”filter them out up front.

League rows collapsed by default with a quick-glance header; expand for details.

Key columns:

Opt-Act (optimal âˆ’ actual)

Projected Result (W / L)

QUES starters? (questionable)

BYE/OUT starters? (bye, out, IR, suspended)

Keep your â€œOptimal vs Current lineupâ€ drill-down inside each row.

ğŸ§± Data inputs we already have

StatChasers weekly projections (CSV) per Season+Week.

Sleeper APIs:

leagues for a user, rosters, users, matchups, league settings/scoring, players, injury status.

ğŸ§® How to compute the columns
1) Filter leagues (no best ball)
const isBestBall = (l: League) =>
  l.settings?.best_ball === 1 || l.scoring_settings?.best_ball === 1 ||
  /best.?ball/i.test(`${l.name} ${l.metadata?.description||""}`);
const leagues = allLeagues.filter(l => !isBestBall(l));

2) Actual vs Optimal points

Actual (Act): Sum locked/current startersâ€™ actual points to date + projected rest-of-week (or simply â€œprojectedâ€ if before kickoff). If you donâ€™t have live totals, use â€œprojected for set starters.â€

Optimal (Opt): For each roster, select the top projected lineup subject to roster constraints (QB/RB/WR/TE/K/DEF + FLEX/SUPER_FLEX), using your StatChasers projections.

Return:

optPoints   // total projected points with optimal starters
actPoints   // total projected points with current starters
optMinusAct = optPoints - actPoints

3) Projected Result (W/L)

For each matchup (head-to-head):

Get opponent roster.

Compute their optPoints (or actPoints if you prefer).

Compare your selected lineupâ€™s total to opponentâ€™s:

const you = useOptimal ? your.optPoints : your.actPoints;
const opp  = useOptimal ? opp.optPoints : opp.actPoints;
const projectedResult = you >= opp ? "W" : "L";


Optionally add a margin and a simple probability:

const margin = you - opp;               // pts
const winProb = 1 / (1 + Math.exp(-margin / 8)); // logistic, 8 â‰ˆ spread scale

4) QUES starters?

Count starters with injury status in {Q, D, SSPD, SUS}:

const quesCodes = new Set(["Q","D","SUS","SSPD","LP","DTD"]);
const quesCount = starters.filter(p => quesCodes.has(p.injury_status)).length;

5) BYE/OUT starters?

Count starters with status in {OUT, IR} or opponent === BYE:

const byeOutCount = starters.filter(p =>
  p.opp === "BYE" || ["O","IR","DNR","NA"].includes(p.injury_status)
).length;


Use Sleeper player feed (or cached mapping) for injury_status, team, pos, and bye weeks. Fall back to schedule matrix for BYE.

ğŸ¨ UI/UX blueprint
Page header

Title: StatChasers Lineup Checker

Subheader: Season / Week selector (drop-downs).

Right side: Sleeper username + â€œAnalyzeâ€ button.

Small badge: Using StatChasers projections for Week NN.

Leagues table (collapsed rows)

Columns (sortable):

League (name â€¢ format chips: PPR/Half/Std â€¢ size)

Record (W-L-T)

Opt-Act (â–² red/green)

Projected Result (W/L + margin)

QUES starters? (count, yellow pill if >0)

BYE/OUT starters? (count, red pill if >0)

Potential Pts (+X.X vs current) â€“ optional

âŒ„ (expand)

Row color accents:

Projected W: subtle green border

Projected L: subtle red border

Opt-Act > 0: green number; < 0: red

Expanded panel per league

Your lineup (Current vs Optimal) side-by-side:

Starters grid with positions and projected points.

List of Recommended changes (X in / Y out).

Opponent card with their total.

Warnings:

3 QUES starters, 1 BYE/OUT starter, Empty bench slot (if you added that feature).

Waiver suggestions (if enabled): top +X players by projection vs your worst starter.

Export/Copy summary button.

Sorting

Default sort: Opt-Act (desc) so the biggest â€œfree pointsâ€ fix is on top. Allow sorting by any column.

ğŸ§© Components (React/Vite + Tailwind, shadcn/ui recommended)

<AppHeader /> â€“ username, week/season, â€œAnalyzeâ€.

<LeaguesTable />

<LeagueRow /> (smart row; fetches/derives metrics)

<LeagueExpand /> (lineups, recommendations)

<StartersGrid /> (position cards, shows Q/OUT/BYE badges)

<LineupDiffList /> (who to swap)

<OpponentCard />

<WarningsBar /> (QUES / BYE/OUT counts, empty bench)

<WaiverSuggestions /> (optional)

ğŸ”Œ Sleeper calls (client-side)

GET /v1/user/{username}/leagues/{season}/nfl

GET /v1/league/{leagueId}/rosters

GET /v1/league/{leagueId}/matchups/{week}

GET /v1/players/nfl (injury status, team, bye) â€“ cache this

GET /v1/league/{leagueId} (scoring settings; you already adjust projections per league)

Respect rate limits; cache per session; run leagues in small concurrency (e.g., 3â€“5 at a time).

ğŸ“Š Projection application (per-league scoring)

You already add columns (pass_att, pass_yd, etc.). For each player row, compute Projected fantasy points using the leagueâ€™s scoring_settings, then store that for lineup calc. Keep the 125 cap you set globally, unless you want to expose it in Admin.

ğŸ“ Optimal lineup selection (deterministic)

Build buckets by position: QB/RB/WR/TE/K/DEF and a flex pool (RB/WR/TE), and superflex (QB+flex if league uses it).

Greedy with backtracking works well:

Fill mandatory slots by highest projection per position.

For FLEX/SF: choose next best from the eligible pool, but swap if a higher-scoring player in a filled slot would increase total via a position-swap.

Guard: never recommend replacing a player with themselves (compare by player_id).

ğŸ§  Column definitions (tooltips)

Opt-Act: â€œProjected points if you set the optimal lineup minus your current starters.â€

Projected Result: â€œW/L based on your total vs your opponentâ€™s total (same method: optimal or currentâ€”pick one and be consistent).â€

QUES starters?: â€œNumber of starters listed as Questionable/Doubtful/Suspended.â€

BYE/OUT starters?: â€œNumber of starters on bye or ruled Out/IR/NA.â€

ğŸ§ª Edge cases & polish

If opponent data missing: compute Projected Result against their current starters only; show â€œN/Aâ€ if no matchup found (some leagues format differently).

Injury/bye from Sleeper sometimes lagsâ€”fall back to your own bye map if present.

When projections are missing for a player, show â€” and exclude them from optimal selection (or treat as 0).

Persist last username + week in localStorage.

ğŸ“¦ Hand-off to Replit AI (paste this)

Implement a new page at /[username]/matchups that lists all non-BestBall Sleeper leagues for that user for the selected Season/Week. The leagues table shows columns: League, Record, Opt-Act, Projected Result (W/L), QUES starters?, BYE/OUT starters?.

Compute Opt-Act by comparing our optimal lineup (built from StatChasers per-league adjusted projections) to the userâ€™s current starters.

Projected Result compares my total vs opponentâ€™s (use optimal for both sides; if opponent data missing, use current starters or â€œN/Aâ€).

QUES starters? counts starters with injury status in {Q, D, SSPD/SUS, LP, DTD}.

BYE/OUT starters? counts starters with bye (opp === "BYE") or injury status in {O, IR, NA}.

Default sort by Opt-Act desc. Each row expands to show Current vs Optimal starters, recommended swaps (never suggest replacing a player with themselves), warnings (QUES/BYE/OUT counts), and optional waiver suggestions.

Hide any â€œbest ballâ€ league: l.settings.best_ball === 1 or text match /best.?ball/i.

Use our existing projection CSV loader and league scoring adjuster. Add a guard: if the CSV fetch returns HTML/404, show a visible error (â€œProjections for Season/Week not foundâ€).

Use shadcn/ui tables, badges for Q/OUT/BYE counts, and Tailwind for styling.

Add tooltips to column headers with the definitions above.